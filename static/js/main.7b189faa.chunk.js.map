{"version":3,"sources":["imgs/select.svg","imgs/visual.svg","imgs/add.svg","components/Node.jsx","algorithms/dijkstra.js","algorithms/astar.js","algorithms/greedy.js","algorithms/dfs.js","algorithms/bfs.js","maze/mazeGeneration.js","components/Grid.jsx","maze/random.js","components/Navitem.jsx","components/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","props","preventDragHandler","e","preventDefault","setNodeandAnimation","type","animation","setState","setNode","setAnimation","state","x","node","y","animationType","DEFAULT","canModify","this","onRef","undefined","typename","nodeType","START","END","WALL","WEIGHT_THREE","WEIGHT_FIVE","WEIGHT_EIGHT","animationname","VISITED","PATH","GENERATE","VISITED_NOANIMATION","PATH_NOANIMATION","className","onMouseDown","onMouseEnter","onDragStart","Component","dijkstra","grid","startNode","endNode","visitedNodes","unvisitedNodes","row","push","distance","length","sort","nodeA","nodeB","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","neighbors","unvisitedNeighbors","filter","neighbor","weight","prevNode","totalDis","manhattanDis","unshift","isConnect","prev","getUnvisitedNeighbors","recursiveDivision","mazeNodes","recursiveDivisionHelper","rowStart","rowEnd","colStart","colEnd","width","height","horizontal","DIR","VERTICAL","HORIZONTAL","Math","floor","random","chooseOrientation","possibleRows","possibleCols","col","randomRowIndex","randomColIndex","selectedRow","selectedCol","passageRow","passageCol","dx","dy","i","ny","nx","DEFAULT_START_X","window","innerWidth","DEFAULT_START_Y","innerHeight","DEFAULT_END_X","DEFAULT_END_Y","Grid","handleMouseDown","isVisualized","isMousePressed","clickedNode","toggleNode","nodetype","modfiedNodes","handleMouseEnter","moveStartorEndNode","handleMouseUp","constructInitGrid","algorithm","chosenAlgorithm","rows","cols","j","mazeType","resetGrid","calculateMazeNodes","generateWall","animateMaze","setTimeout","randomWall","weights","weightType","randomWeight","generateAllWalls","initNode","randomIdx","temp","curNode","traversalGeneration","pop","randomNeighbor","dfsGeneration","interval","speed","resetGridforVisualize","calculateVisualizedNodes","nodesInPath","animateNodes","abs","astar","greedy","dfs","bfs","currNode","findPath","new_type","prevX","prevY","adaptAlgorithm","onMouseUp","onMouseLeave","map","rowIdx","key","id","nodeIdx","ref","Navitem","handleChangeItem","item","curItem","onChangeItem","name","Button","onClick","Dropdown","Toggle","Menu","itemList","Item","onSelect","algorithms","maze","speeds","PathfindingVisualizer","handleChangeAlgorithm","curAlgorithm","handleChangeMaze","curMaze","handleChangeSpeed","speedname","curSpeed","handleChangeNodeType","curNodeType","handleReset","handleGenerateMaze","generateMaze","handleVisualize","visualize","ceil","Navbar","variant","Brand","href","Nav","src","select","alt","add","visual","App","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7b189faa.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/select.f4d9287c.svg\";","module.exports = __webpack_public_path__ + \"static/media/visual.af17a8e4.svg\";","module.exports = __webpack_public_path__ + \"static/media/add.93421e0d.svg\";","import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nclass Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      x: props.node.x,\r\n      y: props.node.y,\r\n      type: props.node.type,\r\n      animation: animationType.DEFAULT,\r\n      canModify: true\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.props.onRef(this);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.props.onRef(undefined);\r\n  }\r\n\r\n  preventDragHandler = e => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  setNodeandAnimation = (type, animation) => {\r\n    this.setState({ type, animation });\r\n  };\r\n\r\n  setNode = type => {\r\n    this.setState({ type });\r\n  };\r\n\r\n  setAnimation = animation => {\r\n    this.setState({ animation });\r\n  };\r\n\r\n  render() {\r\n    let { type } = this.state;\r\n    let typename =\r\n      type === nodeType.START\r\n        ? \"node-start\"\r\n        : type === nodeType.END\r\n        ? \"node-end\"\r\n        : type === nodeType.WALL\r\n        ? \"node-wall\"\r\n        : type === nodeType.WEIGHT_THREE\r\n        ? \"node-three\"\r\n        : type === nodeType.WEIGHT_FIVE\r\n        ? \"node-five\"\r\n        : type === nodeType.WEIGHT_EIGHT\r\n        ? \"node-eight\"\r\n        : \"\";\r\n\r\n    let { animation } = this.state;\r\n    let animationname =\r\n      animation === animationType.VISITED\r\n        ? \"visited\"\r\n        : animation === animationType.PATH\r\n        ? \"path\"\r\n        : animation === animationType.GENERATE\r\n        ? \"generate\"\r\n        : animation === animationType.VISITED_NOANIMATION\r\n        ? \"visited-noanimation\"\r\n        : animation === animationType.PATH_NOANIMATION\r\n        ? \"path-noanimation\"\r\n        : \"\";\r\n\r\n    return (\r\n      <div className={`cell`}>\r\n        <div\r\n          className={`node ${typename} ${animationname}`}\r\n          onMouseDown={() => this.props.onMouseDown(this.state)}\r\n          onMouseEnter={() => this.props.onMouseEnter(this.state)}\r\n          onDragStart={this.preventDragHandler}\r\n        ></div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Node;\r\nexport const nodeType = {\r\n  DEFAULT: 1,\r\n  START: 2,\r\n  END: 3,\r\n  WALL: 4,\r\n  WEIGHT_THREE: 5,\r\n  WEIGHT_FIVE: 6,\r\n  WEIGHT_EIGHT: 7\r\n};\r\n\r\nexport const animationType = {\r\n  DEFAULT: 1,\r\n  VISITED: 2,\r\n  PATH: 3,\r\n  GENERATE: 4,\r\n  VISITED_NOANIMATION: 5,\r\n  PATH_NOANIMATION: 6\r\n};\r\n","import { nodeType } from \"../components/Node\";\r\n\r\n// performs Dijkstra's algorithm\r\nexport function dijkstra(grid, startNode, endNode) {\r\n  let visitedNodes = [];\r\n  let unvisitedNodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      unvisitedNodes.push(node);\r\n    }\r\n  }\r\n  startNode.distance = 0;\r\n  while (unvisitedNodes.length !== 0) {\r\n    // sort the nodes by distance\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n    const closestNode = unvisitedNodes.shift();\r\n\r\n    // trapped by wall\r\n    if (closestNode.distance === Infinity) return visitedNodes;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodes.push(closestNode);\r\n\r\n    // reach goal\r\n    if (closestNode === endNode) return visitedNodes;\r\n\r\n    // update distance for neighbors\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n  return visitedNodes;\r\n}\r\n\r\n// backtracks from the endNode to find the shortest path\r\nexport function findPath(endNode) {\r\n  let nodesInPath = [];\r\n  let currNode = endNode;\r\n\r\n  while (currNode !== null) {\r\n    nodesInPath.unshift(currNode);\r\n    currNode = currNode.prevNode;\r\n  }\r\n\r\n  // check if end node is reached\r\n  nodesInPath = nodesInPath.length === 1 ? [] : nodesInPath;\r\n  return nodesInPath;\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  let neighbors = [];\r\n  const { x, y } = node;\r\n  if (y > 0) neighbors.push(grid[y - 1][x]);\r\n  if (y < grid.length - 1) neighbors.push(grid[y + 1][x]);\r\n  if (x > 0) neighbors.push(grid[y][x - 1]);\r\n  if (x < grid[0].length - 1) neighbors.push(grid[y][x + 1]);\r\n  const unvisitedNeighbors = neighbors.filter(\r\n    neighbor => !neighbor.isVisited && neighbor.type !== nodeType.WALL\r\n  );\r\n\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    if (node.distance + neighbor.weight < neighbor.distance) {\r\n      neighbor.distance = node.distance + neighbor.weight;\r\n      neighbor.prevNode = node;\r\n    }\r\n  }\r\n}\r\n","import { nodeType } from \"../components/Node\";\r\n\r\n// performs astar algorithm\r\nexport function astar(grid, startNode, endNode) {\r\n  let visitedNodes = [];\r\n  let unvisitedNodes = [];\r\n\r\n  // calculate heuristic distance from each node to end node\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      node.manhattanDis = ManhattanDistance(node, endNode);\r\n      unvisitedNodes.push(node);\r\n    }\r\n  }\r\n\r\n  startNode.distance = 0;\r\n  startNode.totalDis = startNode.manhattanDis;\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    // sort the nodes by total distance\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.totalDis - nodeB.totalDis);\r\n    const closestNode = unvisitedNodes.shift();\r\n\r\n    // trapped by wall\r\n    if (closestNode.distance === Infinity) return visitedNodes;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodes.push(closestNode);\r\n\r\n    // reach goal\r\n    if (closestNode === endNode) return visitedNodes;\r\n\r\n    // update distance for neighbors\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n  return visitedNodes;\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  let neighbors = [];\r\n  const { x, y } = node;\r\n  if (y > 0) neighbors.push(grid[y - 1][x]);\r\n  if (y < grid.length - 1) neighbors.push(grid[y + 1][x]);\r\n  if (x > 0) neighbors.push(grid[y][x - 1]);\r\n  if (x < grid[0].length - 1) neighbors.push(grid[y][x + 1]);\r\n  const unvisitedNeighbors = neighbors.filter(\r\n    neighbor => !neighbor.isVisited && neighbor.type !== nodeType.WALL\r\n  );\r\n\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    if (node.distance + neighbor.weight < neighbor.distance) {\r\n      neighbor.distance = node.distance + neighbor.weight;\r\n      neighbor.totalDis = neighbor.distance + neighbor.manhattanDis;\r\n      neighbor.prevNode = node;\r\n    }\r\n  }\r\n}\r\n\r\nfunction ManhattanDistance(nodeA, nodeB) {\r\n  return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y);\r\n}\r\n","import { nodeType } from \"../components/Node\";\r\n\r\n// performs greedy best-first search algorithm\r\nexport function greedy(grid, startNode, endNode) {\r\n  let visitedNodes = [];\r\n  let unvisitedNodes = [];\r\n\r\n  // calculate heuristic distance from each node to end node\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      node.distance = node.weight + ManhattanDistance(node, endNode);\r\n    }\r\n  }\r\n\r\n  unvisitedNodes.push(startNode);\r\n  startNode.isVisited = true;\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    // sort the nodes by total distance\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n    const closestNode = unvisitedNodes.shift();\r\n\r\n    // trapped by wall\r\n    if (closestNode.distance === Infinity) return visitedNodes;\r\n\r\n    visitedNodes.push(closestNode);\r\n\r\n    // reach goal\r\n    if (closestNode === endNode) return visitedNodes;\r\n\r\n    // update distance for neighbors\r\n    updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\r\n  }\r\n\r\n  return visitedNodes;\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\r\n  const { x, y } = node;\r\n  if (\r\n    x > 0 &&\r\n    !grid[y][x - 1].isVisited &&\r\n    grid[y][x - 1].type !== nodeType.WALL\r\n  ) {\r\n    grid[y][x - 1].isVisited = true;\r\n    grid[y][x - 1].prevNode = node;\r\n    unvisitedNodes.push(grid[y][x - 1]);\r\n  }\r\n  if (\r\n    y < grid.length - 1 &&\r\n    !grid[y + 1][x].isVisited &&\r\n    grid[y + 1][x].type !== nodeType.WALL\r\n  ) {\r\n    grid[y + 1][x].isVisited = true;\r\n    grid[y + 1][x].prevNode = node;\r\n    unvisitedNodes.push(grid[y + 1][x]);\r\n  }\r\n  if (\r\n    x < grid[0].length - 1 &&\r\n    !grid[y][x + 1].isVisited &&\r\n    grid[y][x + 1].type !== nodeType.WALL\r\n  ) {\r\n    grid[y][x + 1].isVisited = true;\r\n    grid[y][x + 1].prevNode = node;\r\n    unvisitedNodes.push(grid[y][x + 1]);\r\n  }\r\n  if (\r\n    y > 0 &&\r\n    !grid[y - 1][x].isVisited &&\r\n    grid[y - 1][x].type !== nodeType.WALL\r\n  ) {\r\n    grid[y - 1][x].isVisited = true;\r\n    grid[y - 1][x].prevNode = node;\r\n    unvisitedNodes.push(grid[y - 1][x]);\r\n  }\r\n}\r\n\r\nfunction ManhattanDistance(nodeA, nodeB) {\r\n  return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y);\r\n}\r\n","import { nodeType } from \"../components/Node\";\r\n\r\n// performs depth first search algorithm\r\nexport function dfs(grid, startNode, endNode) {\r\n  const visitedNodes = [];\r\n  let unvisitedNodes = [];\r\n  unvisitedNodes.push(startNode);\r\n  while (unvisitedNodes.length !== 0) {\r\n    // get next cur node\r\n    const curNode = unvisitedNodes.shift();\r\n\r\n    // stack may contain two same nodes\r\n    if (!curNode.isVisited) {\r\n      curNode.isVisited = true;\r\n      visitedNodes.push(curNode);\r\n      if (curNode === endNode) return visitedNodes;\r\n\r\n      // add neighbors to unvisitedNodes\r\n      updateUnvisitedNeighbors(curNode, grid, unvisitedNodes);\r\n    }\r\n  }\r\n\r\n  return visitedNodes;\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\r\n  const { x, y } = node;\r\n  if (\r\n    x > 0 &&\r\n    !grid[y][x - 1].isVisited &&\r\n    grid[y][x - 1].type !== nodeType.WALL\r\n  ) {\r\n    grid[y][x - 1].prevNode = node;\r\n    unvisitedNodes.unshift(grid[y][x - 1]);\r\n  }\r\n  if (\r\n    y < grid.length - 1 &&\r\n    !grid[y + 1][x].isVisited &&\r\n    grid[y + 1][x].type !== nodeType.WALL\r\n  ) {\r\n    grid[y + 1][x].prevNode = node;\r\n    unvisitedNodes.unshift(grid[y + 1][x]);\r\n  }\r\n  if (\r\n    x < grid[0].length - 1 &&\r\n    !grid[y][x + 1].isVisited &&\r\n    grid[y][x + 1].type !== nodeType.WALL\r\n  ) {\r\n    grid[y][x + 1].prevNode = node;\r\n    unvisitedNodes.unshift(grid[y][x + 1]);\r\n  }\r\n  if (\r\n    y > 0 &&\r\n    !grid[y - 1][x].isVisited &&\r\n    grid[y - 1][x].type !== nodeType.WALL\r\n  ) {\r\n    grid[y - 1][x].prevNode = node;\r\n    unvisitedNodes.unshift(grid[y - 1][x]);\r\n  }\r\n}\r\n","import { nodeType } from \"../components/Node\";\r\n\r\n// performs breadth first search algorithm\r\nexport function bfs(grid, startNode, endNode) {\r\n  const visitedNodes = [];\r\n  let unvisitedNodes = [];\r\n  unvisitedNodes.push(startNode);\r\n  startNode.isVisited = true;\r\n  while (unvisitedNodes.length !== 0) {\r\n    // get next cur node\r\n    const curNode = unvisitedNodes.shift();\r\n    visitedNodes.push(curNode);\r\n\r\n    // reach goal\r\n    if (curNode === endNode) return visitedNodes;\r\n\r\n    // add neighbors to unvisitedNodes\r\n    updateUnvisitedNeighbors(curNode, grid, unvisitedNodes);\r\n  }\r\n\r\n  return visitedNodes;\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\r\n  const { x, y } = node;\r\n  if (\r\n    x > 0 &&\r\n    !grid[y][x - 1].isVisited &&\r\n    grid[y][x - 1].type !== nodeType.WALL\r\n  ) {\r\n    grid[y][x - 1].isVisited = true;\r\n    grid[y][x - 1].prevNode = node;\r\n    unvisitedNodes.push(grid[y][x - 1]);\r\n  }\r\n  if (\r\n    y < grid.length - 1 &&\r\n    !grid[y + 1][x].isVisited &&\r\n    grid[y + 1][x].type !== nodeType.WALL\r\n  ) {\r\n    grid[y + 1][x].isVisited = true;\r\n    grid[y + 1][x].prevNode = node;\r\n    unvisitedNodes.push(grid[y + 1][x]);\r\n  }\r\n  if (\r\n    x < grid[0].length - 1 &&\r\n    !grid[y][x + 1].isVisited &&\r\n    grid[y][x + 1].type !== nodeType.WALL\r\n  ) {\r\n    grid[y][x + 1].isVisited = true;\r\n    grid[y][x + 1].prevNode = node;\r\n    unvisitedNodes.push(grid[y][x + 1]);\r\n  }\r\n  if (\r\n    y > 0 &&\r\n    !grid[y - 1][x].isVisited &&\r\n    grid[y - 1][x].type !== nodeType.WALL\r\n  ) {\r\n    grid[y - 1][x].isVisited = true;\r\n    grid[y - 1][x].prevNode = node;\r\n    unvisitedNodes.push(grid[y - 1][x]);\r\n  }\r\n}\r\n","import { nodeType } from \"../components/Node\";\r\n\r\nfunction isConnect(node, grid, prev) {\r\n  const { x, y } = node;\r\n  if (y > 0 && prev !== grid[y - 1][x] && grid[y - 1][x].isVisited) return true;\r\n  if (\r\n    y < grid.length - 1 &&\r\n    prev !== grid[y + 1][x] &&\r\n    grid[y + 1][x].isVisited\r\n  )\r\n    return true;\r\n  if (x > 0 && prev !== grid[y][x - 1] && grid[y][x - 1].isVisited) return true;\r\n  if (\r\n    x < grid[0].length - 1 &&\r\n    prev !== grid[y][x + 1] &&\r\n    grid[y][x + 1].isVisited\r\n  )\r\n    return true;\r\n  return false;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  let neighbors = [];\r\n  const { x, y } = node;\r\n  if (y > 0) neighbors.push(grid[y - 1][x]);\r\n  if (y < grid.length - 1) neighbors.push(grid[y + 1][x]);\r\n  if (x > 0) neighbors.push(grid[y][x - 1]);\r\n  if (x < grid[0].length - 1) neighbors.push(grid[y][x + 1]);\r\n  const unvisitedNeighbors = neighbors.filter(\r\n    neighbor => !neighbor.isVisited && !isConnect(neighbor, grid, node)\r\n  );\r\n  return unvisitedNeighbors;\r\n}\r\n\r\n// depth-first search approach using recursive backtracker and stack\r\nexport function dfsGeneration(grid) {\r\n  // init node\r\n  const initNode =\r\n    grid[0][0].type !== nodeType.START && grid[0][0].type !== nodeType.END\r\n      ? grid[0][0]\r\n      : grid[0][1].type !== nodeType.START && grid[0][1].type !== nodeType.END\r\n      ? grid[0][1]\r\n      : grid[0][2];\r\n  initNode.isVisited = true;\r\n  initNode.type = nodeType.DEFAULT;\r\n\r\n  let mazeNodes = [];\r\n  let visitedNodes = [];\r\n  visitedNodes.push(initNode);\r\n  mazeNodes.push(initNode);\r\n\r\n  while (visitedNodes.length !== 0) {\r\n    let curNode = visitedNodes.pop();\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid);\r\n\r\n    // If the current cell has any neighbours which have not been visited\r\n    if (unvisitedNeighbors.length !== 0) {\r\n      visitedNodes.push(curNode);\r\n      // pick a random neighbor\r\n      let randomNeighbor =\r\n        unvisitedNeighbors[\r\n          Math.floor(Math.random() * unvisitedNeighbors.length)\r\n        ];\r\n      randomNeighbor.isVisited = true; // set visited\r\n      visitedNodes.push(randomNeighbor); // push it to the stack\r\n      if (randomNeighbor.type === nodeType.WALL) {\r\n        randomNeighbor.type = nodeType.DEFAULT; // remove wall\r\n        mazeNodes.push(randomNeighbor); // add to animation nodes\r\n      }\r\n    }\r\n  }\r\n\r\n  return mazeNodes;\r\n}\r\n\r\n// random traversal\r\nexport function traversalGeneration(grid) {\r\n  // init node\r\n  const initNode =\r\n    grid[0][0].type !== nodeType.START && grid[0][0].type !== nodeType.END\r\n      ? grid[0][0]\r\n      : grid[0][1].type !== nodeType.START && grid[0][1].type !== nodeType.END\r\n      ? grid[0][1]\r\n      : grid[0][2];\r\n  initNode.type = nodeType.DEFAULT;\r\n\r\n  let mazeNodes = [];\r\n  let visitedNodes = [];\r\n  visitedNodes.push(initNode);\r\n  mazeNodes.push(initNode);\r\n\r\n  while (visitedNodes.length !== 0) {\r\n    // randomly expand\r\n    let randomIdx = Math.floor(Math.random() * visitedNodes.length);\r\n    // swap for shuffling\r\n    let temp = visitedNodes[randomIdx];\r\n    visitedNodes[randomIdx] = visitedNodes[0];\r\n    visitedNodes[0] = temp;\r\n    let curNode = visitedNodes.shift();\r\n\r\n    // make sure it doesn't connect previous maze\r\n    if (isConnect(curNode, grid, curNode.prevNode)) {\r\n      continue;\r\n    }\r\n    curNode.isVisited = true; // set visited flag\r\n    if (curNode.type === nodeType.WALL) {\r\n      curNode.type = nodeType.DEFAULT; // remove wall\r\n      mazeNodes.push(curNode); // add to animation nodes\r\n    }\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid);\r\n\r\n    // If the current cell has any neighbours which have not been visited\r\n    for (let neighbor of unvisitedNeighbors) {\r\n      neighbor.prevNode = curNode;\r\n      visitedNodes.push(neighbor); // push it to the stack\r\n    }\r\n  }\r\n\r\n  return mazeNodes;\r\n}\r\n\r\n// recursive division\r\nexport function recursiveDivision(grid) {\r\n  let row = grid.length;\r\n  let col = grid[0].length;\r\n  let mazeNodes = [];\r\n  recursiveDivisionHelper(grid, 1, row - 2, 1, col - 2, mazeNodes); // extra room for passage\r\n  return mazeNodes;\r\n}\r\n\r\nfunction chooseOrientation(width, height) {\r\n  if (width > height) {\r\n    return DIR.VERTICAL;\r\n  } else if (width < height) {\r\n    return DIR.HORIZONTAL;\r\n  } else {\r\n    return Math.floor(Math.random() * 2) === 0 ? DIR.HORIZONTAL : DIR.VERTICAL;\r\n  }\r\n}\r\n\r\nfunction recursiveDivisionHelper(\r\n  grid,\r\n  rowStart,\r\n  rowEnd,\r\n  colStart,\r\n  colEnd,\r\n  mazeNodes\r\n) {\r\n  // finish division\r\n  if (rowEnd - rowStart < 0 || colEnd - colStart < 0) {\r\n    return;\r\n  }\r\n  let width = colEnd - colStart + 1;\r\n  let height = rowEnd - rowStart + 1;\r\n  let horizontal = chooseOrientation(width, height) === DIR.HORIZONTAL;\r\n\r\n  // find possible rows and cols\r\n  let possibleRows = [];\r\n  let possibleCols = [];\r\n\r\n  for (\r\n    let row = horizontal ? rowStart : rowStart - 1;\r\n    row <= (horizontal ? rowEnd : rowEnd + 1);\r\n    row += 2\r\n  ) {\r\n    possibleRows.push(row);\r\n  }\r\n\r\n  for (\r\n    let col = horizontal ? colStart - 1 : colStart;\r\n    col <= (horizontal ? colEnd + 1 : colEnd);\r\n    col += 2\r\n  ) {\r\n    possibleCols.push(col);\r\n  }\r\n\r\n  let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\r\n  let randomColIndex = Math.floor(Math.random() * possibleCols.length);\r\n\r\n  // where to draw\r\n  let selectedRow = horizontal ? possibleRows[randomRowIndex] : rowStart;\r\n  let selectedCol = horizontal ? colStart : possibleCols[randomColIndex];\r\n\r\n  // where is the passage : random walls and passage (walls on even, passage on odd)\r\n  let passageRow = horizontal ? selectedRow : possibleRows[randomRowIndex];\r\n  let passageCol = horizontal ? possibleCols[randomColIndex] : selectedCol;\r\n\r\n  // draw walls and passage\r\n  let x = horizontal ? colStart - 1 : selectedCol;\r\n  let y = horizontal ? selectedRow : rowStart - 1;\r\n  let dx = horizontal ? 1 : 0;\r\n  let dy = horizontal ? 0 : 1;\r\n  let length = horizontal ? width + 1 : height + 1;\r\n\r\n  for (let i = 0; i <= length; i++) {\r\n    if (\r\n      (x !== passageCol || y !== passageRow) &&\r\n      grid[y][x].type === nodeType.DEFAULT\r\n    ) {\r\n      grid[y][x].type = nodeType.WALL;\r\n      mazeNodes.push(grid[y][x]);\r\n    }\r\n\r\n    x += dx;\r\n    y += dy;\r\n  }\r\n\r\n  // recursively draw on subfields\r\n  let ny = selectedRow + (horizontal ? 2 : 0);\r\n  let nx = selectedCol + (horizontal ? 0 : 2);\r\n  recursiveDivisionHelper(grid, ny, rowEnd, nx, colEnd, mazeNodes);\r\n\r\n  ny = horizontal ? selectedRow - 2 : rowEnd;\r\n  nx = horizontal ? colEnd : selectedCol - 2;\r\n  recursiveDivisionHelper(grid, rowStart, ny, colStart, nx, mazeNodes);\r\n}\r\n\r\nconst DIR = {\r\n  HORIZONTAL: 0,\r\n  VERTICAL: 1\r\n};\r\n","import React, { Component } from \"react\";\r\nimport Node, { nodeType, animationType } from \"./Node\";\r\nimport { dijkstra, findPath } from \"../algorithms/dijkstra\";\r\nimport { astar } from \"../algorithms/astar\";\r\nimport { greedy } from \"../algorithms/greedy\";\r\nimport { dfs } from \"../algorithms/dfs\";\r\nimport { bfs } from \"../algorithms/bfs\";\r\nimport { randomWall, randomWeight } from \"../maze/random\";\r\nimport {\r\n  dfsGeneration,\r\n  traversalGeneration,\r\n  recursiveDivision\r\n} from \"../maze/mazeGeneration\";\r\n\r\nimport \"./Node.css\";\r\n\r\nconst DEFAULT_START_X = Math.floor((window.innerWidth / 25 + 1) / 4);\r\nconst DEFAULT_START_Y = Math.floor((window.innerHeight / 25 - 9) / 2);\r\nconst DEFAULT_END_X = Math.floor(((window.innerWidth / 25 + 1) * 3) / 4);\r\nconst DEFAULT_END_Y = Math.floor((window.innerHeight / 25 - 9) / 2);\r\n\r\nclass Grid extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.grid = this.constructInitGrid();\r\n    this.startNode = this.grid[DEFAULT_START_Y][DEFAULT_START_X];\r\n    this.endNode = this.grid[DEFAULT_END_Y][DEFAULT_END_X];\r\n    this.isMousePressed = false;\r\n    this.isVisualized = false;\r\n    this.algorithm = null;\r\n    this.chosenAlgorithm = \"Dijkstra\";\r\n    this.nodetype = nodeType.WALL;\r\n    this.clickedNode = null;\r\n    this.modfiedNodes = [];\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.props.onRef(this);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.props.onRef(undefined);\r\n  }\r\n\r\n  resetGrid() {\r\n    if (this.isVisualized) return;\r\n    let rows = this.grid.length;\r\n    let cols = this.grid[0].length;\r\n    this.algorithm = null;\r\n\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < cols; j++) {\r\n        if (\r\n          this.grid[i][j].type !== nodeType.START &&\r\n          this.grid[i][j].type !== nodeType.END\r\n        ) {\r\n          this.grid[i][j].type = nodeType.DEFAULT;\r\n          this.grid[i][j].weight = 1;\r\n          this[`node-${i}-${j}`].setNode(nodeType.DEFAULT);\r\n        }\r\n        this.grid[i][j].prevNode = null;\r\n        this.grid[i][j].distance = Infinity;\r\n        this.grid[i][j].totalDis = Infinity;\r\n        this.grid[i][j].manhattanDis = Infinity;\r\n        this.grid[i][j].isVisited = false;\r\n        this[`node-${i}-${j}`].setAnimation(animationType.DEFAULT);\r\n      }\r\n    }\r\n  }\r\n\r\n  generateMaze(mazeType) {\r\n    if (this.isVisualized) return;\r\n    this.resetGrid(); // reset the grid for new maze\r\n    this.isVisualized = true; // set flag\r\n\r\n    // generate maze nodes in grid\r\n    const mazeNodes = this.calculateMazeNodes(mazeType);\r\n    const generateWall =\r\n      mazeType === \"Random Traversal\" || mazeType === \"Depth-First Search\"\r\n        ? true\r\n        : false;\r\n    this.animateMaze(mazeNodes, generateWall);\r\n  }\r\n\r\n  generateAllWalls() {\r\n    let i = 0;\r\n    for (const row of this.grid) {\r\n      for (const node of row) {\r\n        // generate a grid with all walls\r\n        if (node.type === nodeType.DEFAULT) {\r\n          node.type = nodeType.WALL; // set to wall\r\n          setTimeout(() => {\r\n            this[`node-${node.y}-${node.x}`].setNodeandAnimation(\r\n              nodeType.WALL,\r\n              animationType.GENERATE\r\n            );\r\n          }, 4 * i);\r\n          i++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  calculateMazeNodes(mazeType) {\r\n    let mazeNodes;\r\n    switch (mazeType) {\r\n      case \"Random Wall\":\r\n        mazeNodes = randomWall(this.grid);\r\n        break;\r\n      case \"Random Weight\":\r\n        mazeNodes = randomWeight(this.grid);\r\n        break;\r\n      case \"Random Traversal\":\r\n        this.generateAllWalls();\r\n        mazeNodes = traversalGeneration(this.grid);\r\n        break;\r\n      case \"Depth-First Search\":\r\n        this.generateAllWalls();\r\n        mazeNodes = dfsGeneration(this.grid);\r\n        break;\r\n      case \"Recursive Division\":\r\n        mazeNodes = recursiveDivision(this.grid);\r\n        break;\r\n      default:\r\n        mazeNodes = [];\r\n        break;\r\n    }\r\n    return mazeNodes;\r\n  }\r\n\r\n  animateMaze(mazeNodes, generateWall) {\r\n    let rows = this.grid.length;\r\n    let cols = this.grid[0].length;\r\n    let interval = generateWall ? rows * cols : 0;\r\n    // animate maze nodes\r\n    for (let i = 0; i < mazeNodes.length; i++) {\r\n      setTimeout(() => {\r\n        const node = mazeNodes[i];\r\n        this[`node-${node.y}-${node.x}`].setNodeandAnimation(\r\n          node.type,\r\n          node.type === nodeType.DEFAULT\r\n            ? animationType.DEFAULT\r\n            : animationType.GENERATE\r\n        );\r\n      }, 4 * (i + interval + 1));\r\n    }\r\n\r\n    // finish maze generation\r\n    setTimeout(() => {\r\n      this.isVisualized = false;\r\n    }, 10 + (interval + mazeNodes.length + 1) * 4);\r\n  }\r\n\r\n  resetGridforVisualize() {\r\n    let rows = this.grid.length;\r\n    let cols = this.grid[0].length;\r\n\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < cols; j++) {\r\n        this.grid[i][j].prevNode = null;\r\n        this.grid[i][j].distance = Infinity;\r\n        this.grid[i][j].totalDis = Infinity;\r\n        this.grid[i][j].manhattanDis = Infinity;\r\n        this.grid[i][j].isVisited = false;\r\n        this[`node-${i}-${j}`].setAnimation(animationType.DEFAULT);\r\n      }\r\n    }\r\n  }\r\n\r\n  visualize(algorithm, speed) {\r\n    if (this.isVisualized) return;\r\n    this.isVisualized = true; // set flag\r\n\r\n    // reset the internal of the grid\r\n    // and clear previous visualization\r\n    this.resetGridforVisualize();\r\n    this.algorithm = algorithm;\r\n    const [visitedNodes, nodesInPath] = this.calculateVisualizedNodes(\r\n      algorithm\r\n    );\r\n    this.animateNodes(visitedNodes, nodesInPath, speed);\r\n  }\r\n\r\n  adaptAlgorithm() {\r\n    this.resetGridforVisualize();\r\n    const [visitedNodes, nodesInPath] = this.calculateVisualizedNodes(\r\n      this.chosenAlgorithm\r\n    );\r\n\r\n    for (let i = 0; i < visitedNodes.length + nodesInPath.length; i++) {\r\n      let node;\r\n      if (i < visitedNodes.length) {\r\n        node = visitedNodes[i];\r\n        this[`node-${node.y}-${node.x}`].setAnimation(\r\n          animationType.VISITED_NOANIMATION\r\n        );\r\n      } else {\r\n        node = nodesInPath[i - visitedNodes.length];\r\n        this[`node-${node.y}-${node.x}`].setAnimation(\r\n          animationType.PATH_NOANIMATION\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  calculateVisualizedNodes(algorithm) {\r\n    let visitedNodes, nodesInPath;\r\n    switch (algorithm) {\r\n      case \"Dijkstra\":\r\n        visitedNodes = dijkstra(this.grid, this.startNode, this.endNode);\r\n        break;\r\n      case \"A* Search\":\r\n        visitedNodes = astar(this.grid, this.startNode, this.endNode);\r\n        break;\r\n      case \"Greedy Best-First Search\":\r\n        visitedNodes = greedy(this.grid, this.startNode, this.endNode);\r\n        break;\r\n      case \"Depth-First Search\":\r\n        visitedNodes = dfs(this.grid, this.startNode, this.endNode);\r\n        break;\r\n      case \"Breadth-First Search\":\r\n        visitedNodes = bfs(this.grid, this.startNode, this.endNode);\r\n        break;\r\n      default:\r\n        visitedNodes = dijkstra(this.grid, this.startNode, this.endNode);\r\n        break;\r\n    }\r\n    nodesInPath = findPath(this.endNode);\r\n    return [visitedNodes, nodesInPath];\r\n  }\r\n\r\n  animateNodes(visitedNodes, nodesInPath, speed) {\r\n    for (let i = 0; i <= visitedNodes.length; i++) {\r\n      if (i === visitedNodes.length) {\r\n        setTimeout(() => {\r\n          for (let j = 0; j < nodesInPath.length; j++) {\r\n            setTimeout(() => {\r\n              const node = nodesInPath[j];\r\n              if (node.type === nodeType.START || node.type === nodeType.END) {\r\n                this[`node-${node.y}-${node.x}`].setAnimation(\r\n                  animationType.PATH_NOANIMATION\r\n                );\r\n              } else {\r\n                this[`node-${node.y}-${node.x}`].setAnimation(\r\n                  animationType.PATH\r\n                );\r\n              }\r\n            }, 10 + 2 * speed * j);\r\n          }\r\n        }, 10 + speed * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = visitedNodes[i];\r\n          this[`node-${node.y}-${node.x}`].setAnimation(animationType.VISITED);\r\n        }, 10 + speed * i);\r\n      }\r\n    }\r\n\r\n    // finish visualization\r\n    setTimeout(() => {\r\n      this.isVisualized = false;\r\n    }, 100 + speed * visitedNodes.length + 2 * speed * nodesInPath.length);\r\n  }\r\n\r\n  toggleNode(node, type) {\r\n    let new_type = node.type;\r\n    if (node.type === nodeType.DEFAULT) {\r\n      new_type = type;\r\n      let weight =\r\n        new_type === nodeType.WEIGHT_THREE\r\n          ? 3\r\n          : new_type === nodeType.WEIGHT_FIVE\r\n          ? 5\r\n          : new_type === nodeType.WEIGHT_EIGHT\r\n          ? 8\r\n          : Infinity;\r\n      this.grid[node.y][node.x].weight = weight; // set weight\r\n      this[`node-${node.y}-${node.x}`].setNodeandAnimation(\r\n        new_type,\r\n        animationType.GENERATE\r\n      );\r\n    } else if (\r\n      node.type === nodeType.WALL ||\r\n      node.type === nodeType.WEIGHT_THREE ||\r\n      node.type === nodeType.WEIGHT_FIVE ||\r\n      node.type === nodeType.WEIGHT_EIGHT\r\n    ) {\r\n      new_type = nodeType.DEFAULT;\r\n      this.grid[node.y][node.x].weight = 1; // reset weight to 1\r\n      this[`node-${node.y}-${node.x}`].setNodeandAnimation(\r\n        new_type,\r\n        animationType.DEFAULT\r\n      );\r\n    }\r\n\r\n    this.grid[node.y][node.x].type = new_type;\r\n  }\r\n\r\n  moveStartorEndNode(node) {\r\n    if (node.type === nodeType.DEFAULT) {\r\n      const prevX = this.clickedNode.x;\r\n      const prevY = this.clickedNode.y;\r\n      const { x, y } = node;\r\n      this[`node-${prevY}-${prevX}`].setNode(nodeType.DEFAULT);\r\n      this.grid[prevY][prevX].type = nodeType.DEFAULT;\r\n      this[`node-${y}-${x}`].setNode(this.clickedNode.type);\r\n      this.grid[y][x].type = this.clickedNode.type;\r\n      if (this.grid[y][x].type === nodeType.START) {\r\n        this.startNode = this.grid[y][x];\r\n      } else {\r\n        this.endNode = this.grid[y][x];\r\n      }\r\n      this.clickedNode.x = x;\r\n      this.clickedNode.y = y;\r\n\r\n      if (this.algorithm) {\r\n        this.adaptAlgorithm();\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseDown = node => {\r\n    if (this.isVisualized) return;\r\n    this.isMousePressed = true;\r\n\r\n    // copy the node state\r\n    this.clickedNode = {\r\n      ...node\r\n    };\r\n\r\n    this.toggleNode(node, this.nodetype);\r\n\r\n    // can only modify the node once (for non-start, non-end nodes)\r\n    if (\r\n      this.clickedNode.type !== nodeType.START &&\r\n      this.clickedNode.type !== nodeType.END\r\n    ) {\r\n      node.canModify = false;\r\n      this.modfiedNodes.push(node);\r\n    }\r\n  };\r\n\r\n  handleMouseEnter = node => {\r\n    // can only modify the node once\r\n    if (!this.isMousePressed || !node.canModify) return;\r\n    if (\r\n      this.clickedNode.type !== nodeType.START &&\r\n      this.clickedNode.type !== nodeType.END\r\n    ) {\r\n      this.toggleNode(node, this.nodetype);\r\n\r\n      // set the flag so that the node cannot be modified\r\n      node.canModify = false;\r\n      this.modfiedNodes.push(node);\r\n    } else {\r\n      this.moveStartorEndNode(node);\r\n    }\r\n  };\r\n\r\n  handleMouseUp = () => {\r\n    this.isMousePressed = false;\r\n    this.clickedNode = null;\r\n\r\n    // reset all the modified nodes to can-modifiy\r\n    for (let i = 0; i < this.modfiedNodes.length; i++) {\r\n      const node = this.modfiedNodes[i];\r\n      this[`node-${node.y}-${node.x}`].setState({ canModify: true });\r\n    }\r\n    this.modfiedNodes = [];\r\n  };\r\n\r\n  constructInitGrid() {\r\n    let rows = this.props.rows;\r\n    let cols = this.props.cols;\r\n    let grid = [];\r\n\r\n    for (let i = 0; i < rows; i++) {\r\n      let row = [];\r\n      for (let j = 0; j < cols; j++) {\r\n        const type =\r\n          j === DEFAULT_START_X && i === DEFAULT_START_Y\r\n            ? nodeType.START\r\n            : j === DEFAULT_END_X && i === DEFAULT_END_Y\r\n            ? nodeType.END\r\n            : nodeType.DEFAULT;\r\n        let node = {\r\n          x: j,\r\n          y: i,\r\n          type: type,\r\n          isVisited: false,\r\n          distance: Infinity,\r\n          totalDis: Infinity,\r\n          manhattanDis: Infinity,\r\n          weight: 1,\r\n          prevNode: null\r\n        };\r\n        row.push(node);\r\n      }\r\n      grid.push(row);\r\n    }\r\n    return grid;\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div\r\n        className=\"grid\"\r\n        onMouseUp={() => this.handleMouseUp()}\r\n        onMouseLeave={() => this.handleMouseUp()}\r\n      >\r\n        {this.grid.map((row, rowIdx) => {\r\n          return (\r\n            <div key={rowIdx} id=\"row\">\r\n              {row.map((node, nodeIdx) => {\r\n                return (\r\n                  <Node\r\n                    key={nodeIdx}\r\n                    id={`node-${rowIdx}-${nodeIdx}`}\r\n                    node={node}\r\n                    onMouseDown={this.handleMouseDown}\r\n                    onMouseEnter={this.handleMouseEnter}\r\n                    onRef={ref => (this[`node-${rowIdx}-${nodeIdx}`] = ref)}\r\n                  />\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Grid;\r\n","import { nodeType } from \"../components/Node\";\r\n\r\nexport function randomWall(grid) {\r\n  let mazeNodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      // generate wall on default node\r\n      if (node.type === nodeType.DEFAULT) {\r\n        if (Math.random() >= 0.65) {\r\n          node.type = nodeType.WALL; // set type\r\n          mazeNodes.push(node);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return mazeNodes;\r\n}\r\n\r\nexport function randomWeight(grid) {\r\n  let mazeNodes = [];\r\n  const weights = [\r\n    nodeType.WEIGHT_THREE,\r\n    nodeType.WEIGHT_FIVE,\r\n    nodeType.WEIGHT_EIGHT\r\n  ];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      // generate differnet weights on default node\r\n      if (node.type === nodeType.DEFAULT) {\r\n        if (Math.random() >= 0.4) {\r\n          // randomly choose a weight\r\n          const weightType = weights[Math.floor(Math.random() * 3)];\r\n          let weight =\r\n            weightType === nodeType.WEIGHT_THREE\r\n              ? 3\r\n              : weightType === nodeType.WEIGHT_FIVE\r\n              ? 5\r\n              : weightType === nodeType.WEIGHT_EIGHT\r\n              ? 8\r\n              : 3;\r\n          node.weight = weight; // set weight\r\n          node.type = weightType; // set type\r\n          mazeNodes.push(node);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return mazeNodes;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport { Button } from \"react-bootstrap\";\r\nimport { Dropdown } from \"react-bootstrap\";\r\nimport \"./Navbar.css\";\r\n\r\nclass Navitem extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { name: props.name, type: props.type, curItem: props.curItem };\r\n  }\r\n\r\n  handleChangeItem = item => {\r\n    this.setState({ curItem: item });\r\n    this.props.onChangeItem(item);\r\n  };\r\n\r\n  render() {\r\n    const { type } = this.state;\r\n    if (type === \"button\") {\r\n      return (\r\n        <li>\r\n          <Button id=\"button\" onClick={() => this.props.onClick()}>\r\n            {this.state.name}\r\n          </Button>\r\n        </li>\r\n      );\r\n    } else {\r\n      return (\r\n        <li>\r\n          <Dropdown>\r\n            <Dropdown.Toggle id=\"dropdown-toggle\">\r\n              {this.state.name + \" : \" + this.state.curItem + \"  \"}\r\n            </Dropdown.Toggle>\r\n\r\n            <Dropdown.Menu>\r\n              {this.props.itemList.map(item => {\r\n                return (\r\n                  <Dropdown.Item\r\n                    key={item}\r\n                    onSelect={() => this.handleChangeItem(item)}\r\n                    id=\"dropdown-item\"\r\n                  >\r\n                    {item}\r\n                  </Dropdown.Item>\r\n                );\r\n              })}\r\n            </Dropdown.Menu>\r\n          </Dropdown>\r\n        </li>\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport default Navitem;\r\n","import React, { Component } from \"react\";\r\nimport { Navbar } from \"react-bootstrap\";\r\nimport { Nav } from \"react-bootstrap\";\r\nimport Grid from \"./Grid\";\r\nimport { nodeType } from \"./Node\";\r\nimport Navitem from \"./Navitem\";\r\nimport select from \"../imgs/select.svg\";\r\nimport visual from \"../imgs/visual.svg\";\r\nimport add from \"../imgs/add.svg\";\r\nimport \"./Navbar.css\";\r\n\r\nconst algorithms = [\r\n  \"Dijkstra\",\r\n  \"A* Search\",\r\n  \"Greedy Best-First Search\",\r\n  \"Depth-First Search\",\r\n  \"Breadth-First Search\"\r\n];\r\n\r\nconst maze = [\r\n  \"Random Wall\",\r\n  \"Random Weight\",\r\n  \"Random Traversal\",\r\n  \"Depth-First Search\",\r\n  \"Recursive Division\"\r\n];\r\n\r\nconst weights = [\"Wall\", \"Weight 3\", \"Weight 5\", \"Weight 8\"];\r\n\r\nconst speeds = [\"Fast\", \"Medium\", \"Slow\"];\r\n\r\nclass PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.curAlgorithm = \"Dijkstra\";\r\n    this.curSpeed = \"Fast\";\r\n    this.curNodeType = \"Wall\";\r\n    this.curMaze = \"Random Wall\";\r\n  }\r\n\r\n  handleChangeAlgorithm = algorithm => {\r\n    this.curAlgorithm = algorithm;\r\n    this.grid.chosenAlgorithm = algorithm;\r\n  };\r\n\r\n  handleChangeMaze = mazeType => {\r\n    this.curMaze = mazeType;\r\n  };\r\n\r\n  handleChangeSpeed = speedname => {\r\n    this.curSpeed = speedname;\r\n  };\r\n\r\n  handleChangeNodeType = nodetype => {\r\n    this.curNodeType = nodetype;\r\n    this.grid.nodetype =\r\n      this.curNodeType === \"Weight 3\"\r\n        ? nodeType.WEIGHT_THREE\r\n        : this.curNodeType === \"Weight 5\"\r\n        ? nodeType.WEIGHT_FIVE\r\n        : this.curNodeType === \"Weight 8\"\r\n        ? nodeType.WEIGHT_EIGHT\r\n        : nodeType.WALL;\r\n  };\r\n\r\n  handleReset = () => {\r\n    this.grid.resetGrid();\r\n  };\r\n\r\n  handleGenerateMaze = () => {\r\n    this.grid.generateMaze(this.curMaze);\r\n  };\r\n\r\n  handleVisualize = () => {\r\n    let speed = 12;\r\n    switch (this.curSpeed) {\r\n      case \"Fast\":\r\n        speed = 12;\r\n        break;\r\n      case \"Medium\":\r\n        speed = 16;\r\n        break;\r\n      case \"Slow\":\r\n        speed = 20;\r\n        break;\r\n      default:\r\n        speed = 12;\r\n        break;\r\n    }\r\n    if (window.innerWidth > 1440) {\r\n      speed = speed / 2;\r\n    }\r\n    this.grid.visualize(this.curAlgorithm, speed);\r\n  };\r\n\r\n  render() {\r\n    let row = Math.ceil(window.innerHeight / 25) - 9;\r\n    let col = Math.ceil(window.innerWidth / 25) + 1;\r\n    return (\r\n      <div>\r\n        <Navbar variant=\"custom\">\r\n          <Navbar.Brand href=\"#home\">Pathfinding Visualizer</Navbar.Brand>\r\n          <Nav>\r\n            <Navitem\r\n              name={\"Visualize\"}\r\n              type={\"button\"}\r\n              onClick={this.handleVisualize}\r\n            />\r\n            <Navitem\r\n              name={\"Generate Maze\"}\r\n              type={\"button\"}\r\n              onClick={this.handleGenerateMaze}\r\n            />\r\n            <Navitem\r\n              name={\"Reset\"}\r\n              type={\"button\"}\r\n              onClick={this.handleReset}\r\n            />\r\n            <Navitem\r\n              name={\"Algorithms\"}\r\n              type={\"dropdown\"}\r\n              itemList={algorithms}\r\n              curItem={this.curAlgorithm}\r\n              onChangeItem={this.handleChangeAlgorithm}\r\n            />\r\n            <Navitem\r\n              name={\"Maze\"}\r\n              type={\"dropdown\"}\r\n              itemList={maze}\r\n              curItem={this.curMaze}\r\n              onChangeItem={this.handleChangeMaze}\r\n            />\r\n            <Navitem\r\n              name={\"Add Node\"}\r\n              type={\"dropdown\"}\r\n              itemList={weights}\r\n              curItem={this.curNodeType}\r\n              onChangeItem={this.handleChangeNodeType}\r\n            />\r\n            <Navitem\r\n              name={\"Speed\"}\r\n              type={\"dropdown\"}\r\n              itemList={speeds}\r\n              curItem={this.curSpeed}\r\n              onChangeItem={this.handleChangeSpeed}\r\n            />\r\n          </Nav>\r\n        </Navbar>\r\n        <div id=\"info\">\r\n          <ul>\r\n            <li>\r\n              <div className=\"start\"></div>\r\n              Start Node\r\n            </li>\r\n            <li>\r\n              <div className=\"end\"></div>\r\n              End Node\r\n            </li>\r\n            <li>\r\n              <div className=\"wall\"></div>\r\n              Wall Node\r\n            </li>\r\n            <li>\r\n              <div className=\"weight3\"></div>\r\n              Weight 3\r\n            </li>\r\n            <li>\r\n              <div className=\"weight5\"></div>\r\n              Weight 5\r\n            </li>\r\n            <li>\r\n              <div className=\"weight8\"></div>\r\n              Weight 8\r\n            </li>\r\n            <li>\r\n              <div className=\"unvisited-node\"></div>\r\n              Unvisited Node\r\n            </li>\r\n            <li>\r\n              <div className=\"visited-node\"></div>\r\n              Visited Node\r\n            </li>\r\n            <li>\r\n              <div className=\"path-node\"></div>\r\n              Path Node\r\n            </li>\r\n          </ul>\r\n        </div>\r\n        <div className=\"instruction\">\r\n          <ul>\r\n            <li>\r\n              <img src={select} alt=\"select\" />\r\n              <div> Pick an Algorithm </div>\r\n            </li>\r\n          </ul>\r\n          <ul>\r\n            <li>\r\n              <img src={add} alt=\"select\" />\r\n              <div id=\"middle\"> Add Wall, Weighted Nodes or Generate Maze </div>\r\n            </li>\r\n          </ul>\r\n          <ul>\r\n            <li>\r\n              <img src={visual} alt=\"select\" />\r\n              <div> Visualize and Enjoy! </div>\r\n            </li>\r\n          </ul>\r\n        </div>\r\n        <Grid rows={row} cols={col} onRef={ref => (this.grid = ref)} />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default PathfindingVisualizer;\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport PathfindingVisualizer from \"./components/PathfindingVisualizer\";\r\nimport \"bootstrap/dist/css/bootstrap.css\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\nimport \"typeface-roboto\";\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <PathfindingVisualizer />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}